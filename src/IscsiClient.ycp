/**
 * File:	modules/IscsiClient.ycp
 * Package:	Configuration of iscsi-client
 * Summary:	IscsiClient settings, input and output functions
 * Authors:	Michal Zugec <mzugec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of iscsi-client.
 * Input and output routines.
 */

{

module "IscsiClient";
textdomain "iscsi-client";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Service";
import "Package";
import "Popup";
import "Stage";
import "Confirm";
import "Label";

global list <string> sessions = [];
global list <string> discovered = [];
global list <string> targets = [];
global boolean configured = false;
boolean serviceStatus = false;
map<string, any> config = $[];
map<string, any> ibft = nil;


global map<string, any> getiBFT(){
 if (ibft==nil){
  ibft=$[];
  string from_bios = ((map<string, any>)SCR::Execute(.target.bash_output, "fwparam_ibft -b"))["stdout"]:"";
  foreach(string row, splitstring(from_bios, "\n"), {
   list<string> key_val=splitstring(row, "=");
   if (size(key_val[0]:"")>0) ibft[key_val[0]:""] = key_val[1]:"";
  });
 }
y2milestone("iBFT %1", ibft);
 return ibft;
}


// get accessor for service status
global boolean GetStartService() {
 boolean status = Service::Enabled("open-iscsi");
 y2milestone("Status of open-iscsi %1", status);
 return status;
}

// set accessor for service status
global void SetStartService(boolean status) {
 y2milestone("Set status of open-iscsi to %1", status);
 if (status == true) Service::Enable("open-iscsi");
        else Service::Disable("open-iscsi");
}


// read configuration file
global list <map<string, any> > getConfig(){
 config = (map<string, any>) SCR::Read(.etc.iscsid.all);
 y2milestone("read config %1", config);
 return config["value"]:[];
}

// write temporary changed old config
global void oldConfig(){
 y2milestone("Store temporary config");
 SCR::Write(.etc.iscsid.all, config);
}


global map<string, any> getNode(list<string> rec){
  map<string, any> cmd = (map<string, any>)SCR::Execute(.target.bash_output, "iscsiadm -S -m node -T $TARGET", $["TARGET":rec[1]:"", "IP":rec[0]:""]);
 if (cmd["exit"]:0!=0) return $[];
 map<string, any> auth = $[];
 foreach(string row, splitstring(cmd["stdout"]:"", "\n"), {
 string key = splitstring(row," = ")[0]:"";
 string val = splitstring(row," = ")[3]:"";
 if(val == "<empty>") val="";
  switch(key){
   case("node.session.auth.authmethod"):
		auth["authmethod"]=val;
		break;
   case("node.session.auth.username"):
		auth["username"]=val;
		break;
   case("node.session.auth.password"):
		auth["password"]=val;
		break;
   case("node.session.auth.username_in"):
		auth["username_in"]=val;
		break;
   case("node.session.auth.password_in"):
		auth["password_in"]=val;
		break;
  }
 });
 return auth;
}

// create map from given map in format needed by ini-agent
map<string, any> createMap(map<string, any> old_map, list<string> comments)
{
 string comment = "";
 foreach(string row, comments, {
  comment = sformat("%1%2", comment, row);
  });
 return $[ "name":old_map["KEY"]:"",
           "value":old_map["VALUE"]:"",
           "kind":"value",
           "type":1,
           "comment":comment
         ];
}

// add or modify given map
list <map<string, any> > setOrAdd(list <map<string, any> > old_list, string key, string value){
 list <map<string, any> > new_list = [];
 boolean found = false;
 foreach(map<string, any> row, old_list, {
  if (row["name"]:"" == key){
   found = true;
   row["value"] = value;
  }
  new_list = add(new_list, row);
 });
 if (!found) new_list = add(new_list, createMap($["KEY":key, "VALUE":value], []) );
 return new_list;
}

// delete record with given key
list <map<string, any> > delete(list <map<string, any> > old_list, string key){
 y2milestone("Delete record for %1", key);
 list <map<string, any> > new_list = [];
 foreach(map<string, any> row, old_list, {
  if (row["name"]:"" != key) new_list = add(new_list, row);
 });
 return new_list;
}

// temporary change config for discovery authentication
global void saveConfig(string user_in, string pass_in, string user_out, string pass_out){
 y2milestone("Save config");
 map<string, any> tmp_conf = config;
 list <map<string, any> > tmp_val = tmp_conf["value"]:[];

 if ((size(user_in)>0)&&(size(pass_in)>0)) {
	tmp_val = setOrAdd(tmp_val, "node.session.auth.username", user_in);
	tmp_val = setOrAdd(tmp_val, "node.session.auth.password", pass_in);
	}
  else {
	tmp_val = delete(tmp_val, "node.session.auth.username");
	tmp_val = delete(tmp_val, "node.session.auth.password");
	}

 if ((size(user_out)>0)&&(size(pass_out)>0)) {
	tmp_val = setOrAdd(tmp_val, "discovery.sendtargets.auth.authmethod", "CHAP");
	tmp_val = setOrAdd(tmp_val, "discovery.sendtargets.auth.username", user_out);
	tmp_val = setOrAdd(tmp_val, "discovery.sendtargets.auth.password", pass_out);
	}
  else {
	tmp_val = delete(tmp_val, "discovery.sendtargets.auth.authmethod");
	tmp_val = delete(tmp_val, "discovery.sendtargets.auth.username");
	tmp_val = delete(tmp_val, "discovery.sendtargets.auth.password");
	}
 tmp_conf["value"] = tmp_val;
 SCR::Write(.etc.iscsid.all, tmp_conf);
 SCR::Write(.etc.iscsid, nil);
}

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

// get all discovered targets
global list<string> getDiscovered(){
	 discovered=[];
    map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, "iscsiadm -m node");
	if (size(retcode["stderr"]:"")==0) {
	      list<string> tmp_disc = filter(string row, splitstring(retcode["stdout"]:"", "\n"), {
                        return ( size(row)>0 && (search(row, "session")==nil) );
                        });
	foreach(string row, tmp_disc, {
	 list<string> tmp_row = splitstring(row, " ");
	 discovered = add(discovered, sformat("%1 %2", tmp_row[1]:"", tmp_row[2]:""));
	});
	}
 y2milestone("Discovered sessions %1", discovered);
 return discovered;
}

// get all connected targets
global boolean readSessions(){
 y2milestone("reading current settings");
    map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, "iscsiadm -m session");
//	if ( retcode["exit"]:0 != 0 ) return false;
      list<string> tmp_sessions = [];
      tmp_sessions = filter(string row, splitstring(retcode["stdout"]:"", "\n"), {
                        return ( size(row)>0 && (search(row, "session")==nil) );
                        });
	sessions=[];
	foreach(string row, tmp_sessions, {
	list<string> tmp_row = splitstring(row, " ");
	sessions = add(sessions, sformat("%1 %2", tmp_row[2]:"", tmp_row[3]:""));
	});

  y2milestone("Return list from iscsiadm -m session: %1", sessions);
 return true;
}

// check initiatorname if exist, if no - create it
global boolean checkInitiatorName(){
 boolean ret=true;
 string initiatorname="";
 string file="/etc/initiatorname.iscsi";
 string name_from_bios = getiBFT()["iSCSI_INITIATOR_NAME"]:"";
 y2milestone("Check %1", file);

 if (size((map<string, any>)SCR::Read (.target.lstat, file)) == 0){
   if (size(name_from_bios)>0){
    y2milestone("/etc/initiatorname.iscsi is empty or doesnt exists - replace with name stored in iBFT");
    initiatorname = name_from_bios;
   } else {
	y2milestone("%1 not exist, create", file);

	 map<string, any> output = (map<string, any>)SCR::Execute (.target.bash_output,
								"/sbin/iscsi-iname -p iqn.`date +%Y-%m`.de.suse:01", $[]);
	 if (size(output["stderr"]:"")==0){
	  initiatorname=output["stdout"]:"";
	} else ret = false;
    }
	  ret = (boolean)SCR::Write (.target.string, file, sformat("InitiatorName=%1", initiatorname));
		SCR::Execute (.target.bash, "chmod 0600 $FILE" ,$["FILE":file]);
 } else {
    string initiatorname=((map<string, any>)SCR::Execute(.target.bash_output, "cat /etc/initiatorname.iscsi|cut -d'=' -f2|tr -d '\n'"))["stdout"]:"";
   if (size(name_from_bios)>0 && name_from_bios!=initiatorname){
    Popup::Warning( _("InitiatorName from iBFT and from /etc/initiatorname.iscsi are differ.\nOld initiatorname will be replaced by value from iBFT and create a backup.\nIf you want to use different initiatorname change it in BIOS.") );
    y2milestone("replacing old name %1 by name %2 from iBFT", initiatorname, name_from_bios);
    SCR::Execute(.target.bash, sformat("mv /etc/initiatorname.iscsi /etc/initiatorname.yastbackup ;echo \"InitiatorName=%1\">/etc/initiatorname.iscsi", name_from_bios));

   }

  }
 return ret;
}

// check if package open-iscsi is installed
boolean installed_packages(){
 y2milestone("Check if open-iscsi package installed");
 boolean ret = false;
  if( !Package::InstallMsg( "open-iscsi",
            _("<p>To configure the iSCSI initiator, the <b>%1</b> package must be installed.</p>") +
            _("<p>Install it now?</p>")) )
        {
        Popup::Error( Message::CannotContinueWithoutPackagesInstalled() );
    } else ret = true;
 return ret;
}

// delete deiscovered target from database
global boolean deleteRecord(list<string> record){
 boolean ret = true;
 y2milestone("Delete record %1", record);

    map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, sformat("iscsiadm -m node -T %1 -p %2 --logout", record[1]:"", record[0]:""));
        if (size(retcode["stderr"]:"")>0) return false;

 readSessions();
 return ret;
}

// get (manual/automatic) status of target connecting
global string getStartupStatus(list<string> record){
 string status = "";
 y2milestone("Getting status of record %1", record);
     map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, sformat("iscsiadm -m node -T %1 -p %2", record[1]:"", record[0]:""));
    if (size(retcode["stderr"]:"")>0) return "";
    foreach(string row, splitstring(retcode["stdout"]:"", "\n"), {
     if (issubstring(row, "node.conn[0].startup")){
	status = (splitstring(row, " "))[2]:"";
       break;
      }
    });
 y2milestone("Startup status for %1 is %2", record, status);
 return status;
}

// update authentication value
global boolean setValue(list<string> record, string name, string value){
 y2milestone("set %1  for record %3", name, record);
 string command = sformat("iscsiadm -m node -T %1 -p %2 --op=update --name=%3 --value=%4", record[1]:"", record[0]:"", name, value);
 y2milestone("execute command - %1", command );
 boolean ret = true;
        map<string, any> retcode = (map<string, any>) SCR::Execute(.target.bash_output, command);
    if (size(retcode["stderr"]:"")>0) {
				y2error("%1", retcode["stderr"]:"");
				ret =  false;
				}
y2milestone("return value %1", ret);
 return ret;
}

// check if given target is connected
global boolean connected(list<string> rec, boolean check_ip){
 boolean ret = false;
 foreach(string row, sessions, {
 list<string> list_row = splitstring(row, " ");
  if (list_row[1]:"" == rec[1]:"" && (check_ip ? splitstring(list_row[0]:"", ",")[0]:"" == splitstring(rec[0]:"", ",")[0]:"" : true)){
   ret = true;
   break;
  }
 });
 return ret;
}

boolean autoDiscovery(){
 map<string, any> b = getiBFT();
 if ( b != $[] ){
 map<string, any> result = (map<string, any>)SCR::Execute(.target.bash_output, 
			sformat("iscsiadm -m discovery -t st -p %1:%2", b["iSCSI_TARGET_IPADDR"]:"", b["iSCSI_TARGET_PORT"]:"") );

 if(result["exit"]:0 != 0) {
  Popup::Error(sformat("%1\n%2\n%3 %4:%5", _("Error:"), result["stderr"]:"", _("while discovering"), b["iSCSI_TARGET_IPADDR"]:"", b["iSCSI_TARGET_PORT"]:""));
 } else {
  if (connected([ sformat("%1:%2", b["iSCSI_TARGET_IPADDR"]:"", b["iSCSI_TARGET_PORT"]:""), b["iSCSI_TARGET_NAME"]:""], true))
											y2milestone("Target given from iBFT is already connected");
	else {
  result = (map<string, any>)SCR::Execute(.target.bash_output, 
	sformat("iscsiadm -m node -T %1 -p %2:%3 --login", b["iSCSI_TARGET_NAME"]:"", b["iSCSI_TARGET_IPADDR"]:"", b["iSCSI_TARGET_PORT"]:"") );

   if(result["exit"]:0 != 0) Popup::Error( sformat("%1\n%2\n%3 %4", 
				_("Error:"), result["stderr"]:"", _("while login into"), b["iSCSI_TARGET_NAME"]:""));
   }
  }
 }

 return true;
}

// change startup status (manual/automatic) for target
global boolean setStartupStatus(list<string> record, string status){
 y2milestone("Set startup status for %1 to %2", record, status);
 boolean ret = true;
       map<string, any> retcode = (map<string, any>) SCR::Execute(.target.bash_output, 
			sformat("iscsiadm -m node -T %1 -p %2 --op=update --name=node.conn[0].startup --value=%3", record[1]:"", record[0]:"", status));
    if (size(retcode["stderr"]:"")>0) return false;
 return ret;
}

// get status of open-iscsi
boolean getServiceStatus(){
 boolean ret = true;
 if (Service::Status("open-iscsi") == 0) serviceStatus=true;
 y2milestone("Service status = %1", serviceStatus);
 // if not enabled, start it manually
 if (!serviceStatus) Service::Start("open-iscsi");
 return ret;
}

// set startup status of open-iscsi
boolean setServiceStatus(){
 boolean ret = true;
// if disabled and no connected targets - stop it
// otherwise keep it running
 if (!GetStartService()){
	 readSessions();
	 if (size(sessions)==0) {
		 y2milestone("No active sessions - stopping service");
		 Service::Stop("open-iscsi");
		}
	}
 y2milestone("Status service for open-iscsi: %1", ret);
 return ret;
}

/**
 * Read all iscsi-client settings
 * @return true on success
 */
global boolean Read() {

    /* IscsiClient read dialog caption */
    string caption = _("Initializing iSCSI Initiator Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the database"),
	    /* Progress stage 2/3 */
	    _("Read the previous settings"),
	    /* Progress stage 3/3 */
	    _("Detect the devices")
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress step 2/3 */
	    _("Reading the previous settings..."),
	    /* Progress step 3/3 */
	    _("Detecting the devices..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // check if user is root - must be root
    if(!Confirm::MustBeRoot()) return false;
    Progress::NextStage();
    if(false) return false;
    sleep(sl);

    if(getiBFT()==nil) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    Progress::NextStage();
    // check if required package is installed
    if(!installed_packages()) return false;
    // check initiatorname - create it if no exists
    y2milestone("Check initiator name");
    if(!checkInitiatorName()) return false;
    sleep(sl);

    if(Abort()) return false;
//    Progress::NextStep();
    // read status of service
    if(!getServiceStatus()) return false;
    sleep(sl);

    // read config file
    if(readSessions()==false)
	{
	Report::Error( Message::CannotReadCurrentSettings() );
	return false;
	}
    sleep(sl);

    // read current settings
    if(!autoDiscovery()) return false;
    Progress::NextStage();


    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all iscsi-client settings
 * @return true on success
 */
global boolean Write() {

    /* IscsiClient read dialog caption */
    string caption = _("Saving iSCSI Initiator Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    if(Abort()) return false;
    Progress::NextStage();
    if(false) return false;
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage ();
    if(false) return false;
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage();
    sleep(sl);

    // set open-iscsi service status
    if(!setServiceStatus()) return false;
    return true;
}

/**
 * Get all iscsi-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the iscsi-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
 map result = $[
               "version" : "1.0",
               "service" : serviceStatus,
//               "auth"    : IscsiServerFunctions::getConfig()["auth"]:[],
		"discovered" : discovered,
               "sessions" : sessions,
		"targets" : targets,
		"config" : getConfig()
                ];
  configured = true;
    return result;

}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}




/* EOF */
}
